\documentclass[a4paper,12pt]{article}
\usepackage{float}
\usepackage{etoc}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\usepackage[colorlinks=true,linkcolor=blue]{hyperref}
\usepackage{graphicx}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{customasm}{
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\tiny\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  linewidth=14cm,
  language=Java
}
\lstdefinestyle{gitlog}{
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\tiny\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  linewidth=14cm,
}

\title{Final report}
\author{The Waypointers}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University Assignment Title Page
% LaTeX Template
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (http://en.wikibooks.org/wiki/LaTeX/Title_Creation)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)i

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page

%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\LARGE King's College London}\\[1.5cm] % Name of your university/college
\textsc{\Large 7CCSMGPR Group Project}\\[0.5cm] % Major heading such as course name
%\textsc{\large Minor Heading}\\[0.5cm] % Minor heading such as course title

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries Final project report}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]

%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------
\begin{flushleft}
{\Large \emph{Team:}\\
\textsc{The Waypointers}\\}
Haipei Liu\\
Karlo Santini\\
Michal Szewczak\\
Mengzhu Wang\\
Minghao Zhu\\[3cm]
\end{flushleft}
%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[3cm] % Date, change the \today to a set date if you want to be precise

%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

%\includegraphics{Logo}\\[1cm] % Include a department/university logo - this will require the graphicx package

%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\etocdepthtag.toc{mtchapter}
\etocsettagdepth{mtchapter}{subsection}
\etocsettagdepth{mtappendix}{section}
\tableofcontents

\newpage

\section{Introduction}
The Traffic Simulation System aims to provide users to create a traffic map as they wish. In general, there are three parts in the system: MapPanel, ControlPanel and StatisticsPanel. MapPanel is to show how the traffic map is built while ControlPanel is for users to decide what their traffic map looks like and how do vehicles behave. StatisticsPanel reveals the average speed of different types of vehicles.

Users can control the whole system by clicking start, pause and clear buttons, changing time step, vehicle speed and states, and even using 'debug' to follow every car track and the location of junctions. Specifically, there are four types of vehicle in the system, namely caution cars, normal cars, reckless cars and ambulance. Each type of them have different behaviors, such as speed. The system allows users to decide how many cars run on the road. Users can also choose whether there are traffic lights on junctions or not. They can also change traffic lights' time interval.

\section{Review of related work}
To make a higher achievement, some research of background and review of existed traffic simulators have been done before the start of the design and programming.\\
\subsection{Background}
Traffic simulation system is a model of transportation systems by employing the application of computer software to analyse the whole traffic of a city and help plan, design and operate transportation systems.\\
Over forty years ago, the systems of transportation simulation started. By nowadays, it has been a vital area of discipline in traffic engineering and transportation planning. Various nations are using simulation to aid in their management of transportation networks and different academic institutions are working on the development of the traffic simulation system.\\
This kind of Simulation can study models too complicated for analytical or numerical treatment, can be used for experimental studies, can study detailed relations that might be lost in analytical or numerical treatment and can produce attractive visual demonstrations of present and future scenarios.\\
For the application of traffic simulation, the models are useful from different perspectives. Simulation can be applied to both transportation planning and to traffic system design and operations. In the planning, the simulation models evaluate the impacts of regional urban development patterns on the performance of the transportation infrastructure. Some organizations who works on regional planning use these models to evaluate what-if scenarios in the region. On another side, modeling of transportation system can focus on the operations and design of a smaller scale such as lane types, traffic lights timing and some other related questions. They are investigated to improve local system effectiveness and efficiency.[8]\\
The traffic simulation system can be used for various types of transportation modes whether it is for operations or planning.\\
Traffic simulation software is getting better in different ways. With new achievements in computing, mathematics and engineering, simulation software programs are becoming much more powerful, faster, more realistic and more detail oriented.[12]\\
In general, transportation models can be classified into different models: macroscopic, mesoscopic, and microscopic. Macroscopic models analyse aggregated characteristics of transportation elements, for example, aggregated traffic flow dynamics and zonal-level travel demand analysis. Mesoscopic models deal with traffic elements in small groups, within homogeneously considered elements, such as vehicle platoon dynamics and household-level travel behaviour. Microscopic models focus on individual elements of transportation systems, such as individual vehicle dynamics.
After learning of the background, some of the existed traffic simulators will be discussed in next section.\\
\subsection{Existed traffic simulation software}
By searching online, plenty of existed software with different functions can be found.\\
\subsubsection{Traffic-Simulation.de html5 Version: Ring Road}
\includegraphics[width=12.5cm]{RingRoad.eps}\\
As shown in the figure, this simulator is literally a web page programmed in HTML (Hypertext Markup Language) which mainly used to test the traffic jams and congestion of a Ring Road with various parameters.\\
There are 2 parameters about ‘time’. The first one is ‘Timewarp’ and another is ‘time gap’.\\
Timewarp is related to the changing speed of the whole system. In another word, it is the time of all the vehicles. By changing it, the relative velocity between vehicles will be constant.\\
On the contrary, the time-gap is the changing of the relative velocity between vehicles.\\
The parameter ‘Density’ is the number of vehicles in one map and the parameter ‘Scale’ is used to enable the user to change the size of the simulator. The ‘Truck Fraction’ will control the number of trucks, the ‘desired speed’ is the speed that all the vehicles would like to achieve and the ‘minimum gap’ is the minimum distance between vehicles.\\
Also, this traffic simulation system provides different traffic models for users to analyse. By changing the parameters, the condition of the traffic jam and congestion can be recognized in real time easily.\\
\subsubsection{RoadTrafficSimulator}
\includegraphics[width=12.5cm]{RoadTrafficSimulator.eps}\\
This road traffic simulator is more similar to a road map in the real world. This system is also made by HTML but the main usage of the simulator differs from the ring road traffic simulation. As a road traffic simulator, this system contains roads, junctions, traffic lights and different types of vehicles.
As is demonstrated in the figure, each road has two directions and each direction has two lanes. In this case, the vehicles are able to change lane. Similarly, there are also some parameters in the simulator for users to change.\\
There are 2 highlights in this simulator. Firstly, it enables users to generate the map randomly which is allowed to try different maps to test the traffic system and makes the simulator more reliable. Secondly, the gap of traffic light time changing can be altered. Users can find the best time changing of the traffic light and get the best demonstration of the road simulation.\\
By studying and analysing the background and the existed traffic simulation system. The group members discussed the aim functions and the main requirements and design. In the next section, the details can be discussed. The programming language employed is Java.\\

\section{Requirements}
\subsection{Team work in requirement phase} The requirement analysis is a basic part of the whole project, which will influence every iterative process in the future development. So at the requirement analysis phase, we have twice meetings to discuss and define the requirements. We focused on The Task in Introductory Lecture, and extracted the list of features of the Traffic Simulation System. \\
FE-1: The Traffic Simulation System should simulate different kinds of vehicles, including cars, buses and ambulances.\\
FE-2: The Traffic Simulation System should build a road network which contains multi-lane roads, intersections and roundabouts.\\
FE-3: The Traffic Simulation System should have traffic lights and allow the user to manage relevant policy to control the traffic.\\
FE-4: The Traffic Simulation System should allow the user to define where the vehicles enter and leave the road network.\\
FE-5: The Traffic Simulation System should allow the user to add arbitrary quantity and different kinds of vehicles into the road network at any time.\\
FE-6: The Traffic Simulation System should allow the user to decide the behaviors of drivers of cars, which includes reckless behavior, cautious behavior and normal behavior.\\
FE-7: The Traffic Simulation System should present real time situation of the traffic.\\
FE-8: The Traffic Simulation System should allow the user to control the simulation.\\

\subsection{Functional requirements}  Based on these features, we got the functional requirements of the Traffic Simulation System. These requirements cover the vehicles, road network, traffic lights, the behaviors of drivers, simulation analysis and interaction between the user and the system. The following table will show the details of the functional requirements of the Traffic Simulation System.

\begin{table}[!htbp]
\centering
\label{versiontable}
\caption{Functional requirements}
\begin{tabular}{|p{1.5cm}|p{11cm}|}
\hline
ID & Functional Requirement\\
\hline
FR-1& The Traffic Simulation System should simulate different kinds of vehicles;\\
\hline
FR-2& The Traffic Simulation System should contain a road network, which contains straight roads with junctions;\\
\hline
FR-3& The Traffic Simulation System should allow user to set traffic lights in the junctions;\\
\hline
FR-4& The Traffic Simulation System should let vehicle enter the road network at a random entry, and leave at a random exit as well;\\
\hline
FR-5& The Traffic Simulation System should allow the user to add different kinds of vehicles into the road network;\\
\hline
FR-6& The Traffic Simulation System should simulate different behaviors of drivers, which includes reckless behavior, cautious behavior and normal behavior;\\
\hline
FR-7& The Traffic Simulation System should present real-time situation of the traffic, this should be a statistic result;\\
\hline
FR-8& The Traffic Simulation System should allow the user to control the simulation, including the starting or pausing, the time step, the speed of simulation, the states per second, the debug model and the interval of switching traffic lights.\\
\hline
\end{tabular}
\end{table}

\subsection{Quality requirement} To ensure the robustness of the system, we also determined the quality requirements of the system, which can improve the operation of the system. The details of the quality requirements of the Traffic Simulation System will be stated in the following table.

\begin{table}[!htbp]
\centering
\label{versiontable}
\caption{Quality Requirements}
\begin{tabular}{|p{1.5cm}|p{3cm}|p{8cm}|}
\hline
ID & Property & Functional Requirement\\
\hline
QR-1& Functionality&  The Traffic Simulation System should meet all the requirements from the users, and implement all the functions of the system;\\
\hline
QR-2& Maintainability& The Traffic Simulation System should be easy to maintain, the developer can modify the system and remove the defects very efficiently;\\
\hline
QR-3& Efficiency& The Traffic Simulation System should promptly respond to user's operations;\\
\hline
QR-4& Reliability& The Traffic Simulation System should ensure the low frequency of system crashes;\\
\hline
QR-5& Usability& The Traffic Simulation System should have a clear GUI interface that use can use it immediately and easily.\\
\hline
\end{tabular}
\end{table}

\section{Design}

\section{Implementation}
\subsection{Interaction between the user and the system}
\subsubsection{Description} The majority of interactions between the user and the system come from the Control Panel. The user can control the system through the components in the Control Panel, and the relevant corresponding will be showed in the specific area. The Control Panel can be separated into three parts, they are Simulation Controller, Vehicles Controller and the Traffic Lights Controller. Though Simulation Controller part, the user can control the starting or pausing of the simulation, the clear of the whole simulation, the time step of the simulation, the speed of the timer, the states per second of the simulation, and the display of the debug mode. As to the Vehicles Controller, the user can set the percentage of the different kinds of vehicles, and the behaviors of the drivers. In addition, the interval of switching the traffic lights can be set by the user through the Traffic Lights Controller.
The other interactions happen on the Map Panel. First of all, the user can drag and move the map to see more details of the simulation. Because the size of the map is bigger than the size of the Map Panel, we use this solution to help the user to see the complete map information. Then the user can set or remove the traffic lights just by clicking on the specific junction showed on the map.

\subsubsection{Design and implementation}
\includegraphics[width=12.5cm]{interactionClassGraph.eps}
\paragraph{Class PanelMouseAction} implements MouseInputListener, which is added on the Map Panel. It belongs to ``gui" package. The main task for this class is processing the requests from the Mouse operation in the Map Panel. The first operation is dragging the map. It is easy to implement the function of dragging the panel, however, it will get more complex if we take the range into consider. The map in our system is a rectangle that has limited length and height. So the range of dragging should be the minimum length and width to maximum length and width. The second one is set or remove the traffic lights. In order to ensure the operability, the selectable range should be enlarged to the whole junction. After clicking the junction, the relevant parameters will be sent back to the ``common" package.
\paragraph{Class ControlPanel} extends JPanel, which is added on the Main Frame. It belongs to ``gui" package. It is responsible for most of the interaction works. It uses the static parameter simulationListener in MainFrame to transfer inputs from the user to the server end mostly. While for the setting of debug mode, it transfers the Boolean parameter to the MapPanel directly. In addition, it should do the necessary checking of inputs before passing the values to the server side. For the invalid inputs, it will generate a JDialog object to prompt the user to make the appropriate changes. As to the control of starting or pausing, clearing of the simulation. It will use stateProviderController to control the main thread of the system.
\paragraph{Class ControlPanelDocumentListnener} implements DocumentListener, which is added to the text fields in Control Panel. It belongs to ``gui" package. It is used to check the validity of inputs. If the input is invalid, a JDialog that has related information will be generated.
\paragraph{Class StateProviderController} extends Thread, which is the main thread of the simulation. It belongs to ``thewaypointers.trafficsimulator" package, ControlPanel in ``gui" package holds the reference to it. The thread is generated by the Bootstrapper class, and it keeps sleep state until the user starts the simulation. The Boolean parameter isSleep controlled the starting and pausing of the simulation. When the user chooses to clear the simulation, a new StateProvider will be passed to the simulation.
\paragraph{Class Bootstrapper} is generated by the main starter of the system. It belongs to ``thewaypointers.trafficsimulator" package, and the StateProviderController holds the reference to it. It is used to create the main thread StateProviderController and start it. It also generates the Main Frame and set relevant parameters of the simulation.


\subsubsection{Detailed description of the main function}

\paragraph{ChangeListener trafficLightTimeChange} This function is used to pass the value of the interval of switching traffic lights to the package ``common". The input value that is set by the user will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame.
\paragraph{ChangeListener debugChange} This function is used to pass a Boolean value to MapPanel to control whether display debug mode.
\paragraph{ChangeListener statesPerSecondsChange} This function is used to pass the value of the states per seconds of the simulation to the package ``common". The input value that is set by the user will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame.
\paragraph{ChangeListener simulationSpeedChange} This function is used to pass the value of the speed of timer to the package ``common". The input value that is set by the user will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame.
\paragraph{ChangeListener timeStepChange}This function is used to pass the value of the time step of simulation to the package ``common". The input value that is set by the user will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame.
\paragraph{startPausePerformed(ActionEvent evt)} This function is used to control the main thread of the simulation. When the user presses the start button, the simulation will get start and the button will change to pause. When the user presses the pause button, the simulation will pause and the button change to start.
\paragraph{clearPerformed(ActionEvent evt)} This function is used to end the main thread of the simulation. When the user presses the clear button, the simulation will stop immediately.
\paragraph{submitPerformed(ActionEvent evt)} This function is used to pass the percentages of different kinds of vehicles to the package ``common''. The input value that is set by the user will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame. At the same time, the validity of the input will be checked in this method.

\paragraph{mouseClicked(ActionEvent evt)} This function allows the user to set traffic lights at junctions. When the user clicks on a junction showed on the map, it will set or remove the traffic lights on this junction. The chosen traffic light will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame.
\paragraph{mouseDragged(ActionEvent evt)} This function allows the user to drag map inside of the MapPanel and see more details of the simulation. When the user drags the map, the system will check whether the map is in the visible field. If the new location out of the range, the map will be set at the border of the MapPanel.

\paragraph{pauseSimulation()} This function is used to control the main thread of the simulation. It will be invoked when the user presses the ``start/pause'' button. If the operation is  ``start" then the thread will run as normal, while if the operation is ``pause" then the thread will sleep until the user starts the simulation again.
\paragraph{clearSimulation()} This function is used to end the main thread of the simulation. It will be invoked when the user presses the clear button. The thread will stop immediately and generate a new thread of the simulation.
\paragraph{run()}This reconstructed function is used to execute the main thread of the simulation. It will be invoked when the system starts up.

\paragraph{insertUpdate(DocumentEvent e)} This reconstructed function is used to check the validity of the inputs. It will be invoked when the text field has new inputs.  If the input is invalid, a JDialog will pop up to display related information.

\paragraph{bootstrap(String[] args)} This function is used to generate a new thread StateProviderController and start the thread. It also generates the new MainFrame with relevant parameters of simulation controlling. This function is invoked by the main starter of the system.

\subsection{GUI part}

Basically, GUI is to display performance of the whole system, showing the results of how the system runs. In GUI, we draw traffic road on class MapPanel. The MapPanel mainly consist of five parts: to paint road, vehicle, traffic lights, labels and to get statistical data.

\subsubsection{compute$\_$xy( )}
When drawing road, we get the junctions and roads from background. One thing we have to deal with is to compute the coordinate of each junction and road, then draw them on the MapPanel. We assume that the first junction we get from our background is on the top left of the map. So we make the coordinate as $(x,y)=(road_length, road_length)$. Afterwards, based on the location of the first junction, we compute the rest roads and junctions until finishing the whole map. On the contrary, if the first junction we get is not located on the top left, then we move the junction to its correct location. As long as we complete the road map, achieving coordinate of each junction, we can easily compute the relative coordinates of vehicle and traffic lights. Finally, we draw the whole traffic map.

\subsubsection{drawVehicleInJunction( )}
Considering vehicles turning on junctions, we first divide turning situation into the following eight parts, where $\alpha$ represents its turning angle. Then using Java function, AffineTransform(), to rotate the vehicle towards its right way.
\begin{center}
	\includegraphics[width=14cm]{GUI_p1.eps}
\end{center}

\subsubsection{RecordStatistics( )}
Our system will collect the travel distance of every car and then compute their average speed for further analysis, showing on StatisticsPanel. We create a list for the whole system and list information for cars, running time and running distance. The pseudo-code shows as below:
\begin{center}
	\includegraphics[width=6cm] {GUI_p2.eps}
\end{center}
\subsection{Test}
After finishing the programming of the functions. ‘Test’ is a significant part of the whole project. However, it is too complex to test the units manually. Also, it is not able to find the exact location of the BUGs in the programme.\\
In this case, it is crucial to create a test class to check if the units work well.\\
\subsubsection{JUnit}
JUnit is a unit testing framework for the Java programming language.It has been a significant part in the development of test-driven development and is one of a family of unit testing frameworks which is collectively known as xUnit that originated with SUnit.\\
In 2013, there is a research survey hosted on GitHub across 10,000 Java projects performed found that JUnit was the most popular and commonly used  included external library. Each library was used by 30.7 percent of projects.\\
JUnit provides overloaded assertion methods for all primitive types and Objects and arrays (of primitives or Objects). In this method, the parameter order is expected value followed by actual value. Optionally the first parameter can be a String message that is output on failure. There is a slightly different assertion, assertThat that has parameters of the optional failure message, the actual value, and a Matcher object. It needs to be notice that expected and actual are reversed compared to the other assert methods.\\
In this project, 3 main motheds are utilized: ‘arrange’ ‘act’ and ‘assert’ and the most important method is assertThat.\\
\subsubsection{What tested}
Plenty of classes tested in this project. Shown as the picture below.\\
\includegraphics[width=5cm]{testclass.eps}\\
The first test is the FirstVersionProviderTest. This class is used to check if the FirstVesionProvider works well which provides some basic functions for the first version of the traffic simulation software. \\
JunctionLocationDTOTest and MapDTOTest are mainly to test the JunctionLocationDTO and the MapDTO to see if this class can generate the map and the location of junctions properly.
In the test of MapDTO, different number of roads are added in the ‘act’ mothed and in the ‘assert’ the number of junctions, number of nodes ,number of roads and the road direction are checked to test if the map are generated correctly.\\
Beside, GuiControllerTest helps test the GuiController class and MapWorldStateFactory helps convert existed ‘xml’ format maps to the maps will be shown in GUI. By testing this class, it is able to know if both MapWorldStateFactory and RoadMap class works well because the MapWorldStateFactory go through to RoadMap. The functions tested are the junctions, number of junctions, number of nodes, number of roads and the direction of roads and the details of traffic lights.\\
Some other useful tests are created as well such as FloatPointTest, FirstVersionStarterTest, JunctionLocationTestStarterTest, RoadNetworkStarterTest and TrafficSimulatorStarterTest. The aim to create these tests are testing the function of the starters to ensure they are working properly.\\
After testing, BUGs are found and fixed by debuging.\\


\section{Teamwork}

\subsection{Tools and libraries used}

\subsubsection*{Tools and applications}

\begin{itemize}
	\item Git\footnote{\url{https://git-scm.com/}} - version control
	\item GitHub\footnote{\url{https://github.com/}} - Git repository management, task assignment, teamwork
	\item \LaTeX\footnote{\url{https://www.latex-project.org/}} - typesetting system, for creating documentation
	\item Gliffy\footnote{\url{https://www.gliffy.com/}} - a Chrome app for creating diagrams
	\item Apache Maven\footnote{\url{https://maven.apache.org/}} - a build tool for building the project easily and for dependency management
	\item Travis CI\footnote{\url{https://travis-ci.org/}} - a continuous integration tool that integrates into GitHub and builds every commit pushed to the repository (in our case - using Maven), also checking if the tests pass
	\item IntelliJ IDEA\footnote{\url{https://www.jetbrains.com/idea/}} - a cross-platform IDE for development in Java (and more). To minimize potential hassles with different development environments, we all agreed on using the same IDE.
\end{itemize}


A significant fact to note that is our team used all the major operating systems (Windows, OS X, Linux), so we focused on choosing cross-platform tools. The only troubles that arised from that were minor layout differences in the Swing GUI of our system.

\subsubsection*{Libraries}

\begin{itemize}
	\item JDK 1.8\footnote{\url{http://www.oracle.com/technetwork/java/javase/downloads/index.html}} - We had several reasons for choosing Java: \begin{itemize}
		\item Familiarity of team members with it
		\item Available on all platforms
		\item Good capabilities of cross-platform GUI
		\item Strong typing allowing for easier maintaining of code integrity
	\end{itemize}
	We chose version 8 because it introduces many much-needed improvements for the language like lambda functions or the Stream API.
	\item JUnit 4.12\footnote{\url{http://junit.org/junit4/}} - The ``de facto'' unit testing library for Java. Good integration with IntelliJ IDEA and Maven.
	\item FEST-Assert 2.0M5\footnote{\url{https://github.com/alexruiz/fest-assert-2.x}} - A library to make assertions in unit tests more readable and easier to compose.
	\item JGraphT 0.7.3 \footnote{\url{http://jgrapht.org/}} - A graph library to take advantage of graph representation of the road network, mainly implementing pathfinding for vehicles.
	\item XStream 1.2.2 \footnote{\url{http://x-stream.github.io/}} - An XML serialization library to bring reading and writing XML road maps to life.
\end{itemize}

\subsection{Process}
We used an Agile method to manage out project. We divided project time into 8 week-long iterations, which started with a meeting every Thursday. Every team member was present every Thursday, barring some serious circumstances. During every meeting, we established the goals to achieve in the next iteration and every team member was assigned tasks to complete within the timeframe of the iteration. If any tasks were leftover from the previous iteration, they were reassigned. The tasks were recorded as GitHub Issues, which allowed us to set labels, current iteration (as ``milestone'') and assignee.

We maintained three levels of branches in the Git repository:
\begin{itemize}
    \item \emph{master} - this branch was the top-level branch, intended for releasing working snapshots of the system. We ended up not using it, because the system was not very usable until we implemented the control panel and statstics in full, which was late in the project cycle.
    \item \emph{dev} - the development branch. Here, the team members merged their new features. If there were merge conflicts, they were resolved on the feature branches so pull requests could be managed from the website easily. All code had to build and pass its tests on Travis.
    \item Feature branches - active development branches. Normally, there was one branch per task belonging to one team member. They were merged into dev when the task was finished (or when the task achieved a stable, partially completed state).
\end{itemize}

There was also a fourth kind of branch, created ad hoc for urgent matters - mostly bugfix branches. Those operated similarly to feature branches, but were not created at the start of the iteration.

When a team member started working on task, they created a new feature branch with the following name format:
$$\verb|feat-{name_of_issue}-{number_of_issue}|$$ This proved very useful for quickly finding an issue associated with a branch and vice versa.

When the work was done, the author submitted a pull request closing the issue. At this point, another team member reviewed the code, checking the Travis build and tests status and potentially making suggestions about improvements.

When the reviewer and the submitter were both satisfied with the state of the pull request, the reviewer closed the pull request and the task by merging the changes into \emph{dev}. We didn't encounter any problems with unresolvable disagreements, but if they occured, we would resolve them by assigning a mediator, and if that failed, a team-wide vote.

\section{Evaluation}

Although we achieved a usable version of the system, we did not have time to implement all features we wanted to - namely, multi-lane roads and buses. This was simply due to the fact that each other's abilities were unknown to us at the start, and the tasks ended up taking more time than planned.

On per-iteration basis, it was also visible that issues were oftes still open after deadlines. That was to be expected, though - since we did not know about each others' cababilities and experience, it was better to assign a considerable amount of work and close it a couple of days after the deadline than to assign little and make a person not contribute much during an iteration.

On the other hand, we have also implemented features we have not planned in the original requirements document. The most prominent example is the capability of reading roadmaps from XML files, which we created in order to store different road map configurations in a manageable way.

\subsubsection*{What went well}
\begin{itemize}
	\item The architecture - Dividing the system into clearly delimited components with defined interfaces was certainly a good idea that reduced complexity in the project and allowed for the simulation and the display part to be developed almost independently. Because we defined the GUI to refresh when accepting a new simulation state, and the simulation to be a state machine which can be asked to produce a new state occuring after N miliseconds, those two components could be easily connected and controlled together.
	\item GitHub Issues - Ideal task assignment system for our use case. We never needed anything more complicated than Issues, and thanks to it being a part of GitHub we managed a very close integration of our tasks with pull requests and the code. It even allowed us to close associated issues while merging pull requests automatically.
	\item Continuous Integration - Setting up Travis was easy, it integrated into GitHub automatically, and it allowed us to catch many broken tests and compilation errors which we would miss otherwise.
	\item Graph representation of the road network - Representing the road network as a graph instead of a 2-dimensional matrix allowed us to focus on what happens on the roads and not where the roads and vehicles are located in two-dimensional space. This also allowed us to pass only the essential world information to the GUI, which could freely display it in the most convenient way. The only disadvantage was that we had to represent junctions in two-dimensional form anyway for the purpose of implementing turning and collision detection on the junction, but since each junction uses its own local coordinates, it is still a clearer representation than full 2D.
\end{itemize}

\subsubsection*{What went less well}
\begin{itemize}
	\item Testing - We have extensively unit-tested several complex areas of code and created several test startup configurations for the system, but in general testing should have been encouraged or enforced more, especially in the simulation component. Both code and the produced effects quickly grew in complexity, which led to manual debugging taking hours. Total debugging time was probably greater than the amount of time writing tests would have taken, and it would also increase flexibility of the code.
\end{itemize}

\subsubsection*{Further improvements for the future}

An obvious way to continue the project in the future is to make the simulation more complex, adding multi-lane roads, different road kinds like main roads and small (rural) roads, roundabouts, buses. It would make the system more realisting and the configurations more interesting to manipulate.

GUI could be made more beautiful: images instead of vector graphics could be added.

Because we have implemented an XML format for road networks, loading arbitrary maps from outside is easy. A map editor can be created to graphically create new maps which could be used in the system.

\section{Peer assessment}

Peer assessment results are shown in table \ref{table:assessment}.

\begin{table}[!htb]
\centering
\caption{Peer assessment}
\label{table:assessment}
\begin{tabular}{|l|l|}
\hline
Haipei Liu      & 20.3 \\ \hline
Karlo Santini   & 19.9 \\ \hline
Michal Szewczak & 24.8 \\ \hline
Mengzhu Wang    & 20.6 \\ \hline
Minghao Zhu     & 14.4 \\ \hline
\end{tabular}
\end{table}

\newpage
\appendix

\etocdepthtag.toc{mtappendix}
\etocsettagdepth{mtchapter}{none}
\etocsettagdepth{mtappendix}{subsection}
\tableofcontents‎‎

\section{Git log}

\lstinputlisting[style=gitlog]{gitlog.txt}

\section{Main source code}

\input{main_code.tex}

\section{Test source code}

\input{test_code.tex}

\end{document}
