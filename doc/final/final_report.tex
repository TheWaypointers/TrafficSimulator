\documentclass[a4paper,12pt]{article}
\usepackage{float}
\usepackage{etoc}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\usepackage[colorlinks=true,linkcolor=blue]{hyperref}
\usepackage{graphicx}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

 \lstset{frame=tb,
 	language=Java,
 	aboveskip=3mm,
 	belowskip=3mm,
 	showstringspaces=false,
 	columns=flexible,
 	basicstyle={\small\ttfamily},
 	numbers=none,
 	numberstyle=\tiny\color{gray},
 	keywordstyle=\color{blue},
 	commentstyle=\color{dkgreen},
 	stringstyle=\color{mauve},
 	breaklines=true,
 	breakatwhitespace=true,
 	tabsize=3
 }

\lstdefinestyle{customasm}{
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\tiny\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  linewidth=14cm,
  language=Java
}
\lstdefinestyle{gitlog}{
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\tiny\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  linewidth=14cm,
}

\title{Final report}
\author{The Waypointers}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University Assignment Title Page
% LaTeX Template
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (http://en.wikibooks.org/wiki/LaTeX/Title_Creation)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)i

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page

%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\LARGE King's College London}\\[1.5cm] % Name of your university/college
\textsc{\Large 7CCSMGPR Group Project}\\[0.5cm] % Major heading such as course name
%\textsc{\large Minor Heading}\\[0.5cm] % Minor heading such as course title

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries Final project report}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]

%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------
\begin{flushleft}
{\Large \emph{Team:}\\
\textsc{The Waypointers}\\}
Haipei Liu\\
Karlo Santini\\
Michal Szewczak\\
Mengzhu Wang\\
Minghao Zhu\\[3cm]
\end{flushleft}
%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[3cm] % Date, change the \today to a set date if you want to be precise

%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

%\includegraphics{Logo}\\[1cm] % Include a department/university logo - this will require the graphicx package

%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\etocdepthtag.toc{mtchapter}
\etocsettagdepth{mtchapter}{subsection}
\etocsettagdepth{mtappendix}{section}
\tableofcontents

\newpage

\section{Introduction}
The Traffic Simulation System aims to provide users to create a traffic map as they wish. In general, there are three parts in the system: MapPanel, ControlPanel and StatisticsPanel. MapPanel is to show how the traffic map is built while ControlPanel is for users to decide what their traffic map looks like and how do vehicles behave. StatisticsPanel reveals the average speed of different types of vehicles.

Users can control the whole system by clicking start, pause and clear buttons, changing time step, vehicle speed and states, and even using 'debug' to follow every car track and the location of junctions. Specifically, there are four types of vehicle in the system, namely caution cars, normal cars, reckless cars and ambulance. Each type of them have different behaviors, such as speed. The system allows users to decide how many cars run on the road. Users can also choose whether there are traffic lights on junctions or not. They can also change traffic lights' time interval.

\section{Review of related work}

\section{Requirements}
\subsection{Team work in requirement phase} The requirement analysis is a basic part of the whole project, which will influence every iterative process in the future development. So at the requirement analysis phase, we have twice meetings to discuss and define the requirements. We focused on The Task in Introductory Lecture, and extracted the list of features of the Traffic Simulation System. \\
FE-1: The Traffic Simulation System should simulate different kinds of vehicles, including cars, buses and ambulances.\\
FE-2: The Traffic Simulation System should build a road network which contains multi-lane roads, intersections and roundabouts.\\
FE-3: The Traffic Simulation System should have traffic lights and allow the user to manage relevant policy to control the traffic.\\
FE-4: The Traffic Simulation System should allow the user to define where the vehicles enter and leave the road network.\\
FE-5: The Traffic Simulation System should allow the user to add arbitrary quantity and different kinds of vehicles into the road network at any time.\\
FE-6: The Traffic Simulation System should allow the user to decide the behaviors of drivers of cars, which includes reckless behavior, cautious behavior and normal behavior.\\
FE-7: The Traffic Simulation System should present real time situation of the traffic.\\
FE-8: The Traffic Simulation System should allow the user to control the simulation.\\

\subsection{Functional requirements}  Based on these features, we got the functional requirements of the Traffic Simulation System. These requirements cover the vehicles, road network, traffic lights, the behaviors of drivers, simulation analysis and interaction between the user and the system. The following table will show the details of the functional requirements of the Traffic Simulation System.

\begin{table}[!htbp]
\centering
\label{versiontable}
\caption{Functional requirements}
\begin{tabular}{|p{1.5cm}|p{11cm}|}
\hline
ID & Functional Requirement\\
\hline
FR-1& The Traffic Simulation System should simulate different kinds of vehicles;\\
\hline
FR-2& The Traffic Simulation System should contain a road network, which contains straight roads with junctions;\\
\hline
FR-3& The Traffic Simulation System should allow user to set traffic lights in the junctions;\\
\hline
FR-4& The Traffic Simulation System should let vehicle enter the road network at a random entry, and leave at a random exit as well;\\
\hline
FR-5& The Traffic Simulation System should allow the user to add different kinds of vehicles into the road network;\\
\hline
FR-6& The Traffic Simulation System should simulate different behaviors of drivers, which includes reckless behavior, cautious behavior and normal behavior;\\
\hline
FR-7& The Traffic Simulation System should present real-time situation of the traffic, this should be a statistic result;\\
\hline
FR-8& The Traffic Simulation System should allow the user to control the simulation, including the starting or pausing, the time step, the speed of simulation, the states per second, the debug model and the interval of switching traffic lights.\\
\hline
\end{tabular}
\end{table}

\subsection{Quality requirement} To ensure the robustness of the system, we also determined the quality requirements of the system, which can improve the operation of the system. The details of the quality requirements of the Traffic Simulation System will be stated in the following table.

\begin{table}[!htbp]
\centering
\label{versiontable}
\caption{Quality Requirements}
\begin{tabular}{|p{1.5cm}|p{3cm}|p{8cm}|}
\hline
ID & Property & Functional Requirement\\
\hline
QR-1& Functionality&  The Traffic Simulation System should meet all the requirements from the users, and implement all the functions of the system;\\
\hline
QR-2& Maintainability& The Traffic Simulation System should be easy to maintain, the developer can modify the system and remove the defects very efficiently;\\
\hline
QR-3& Efficiency& The Traffic Simulation System should promptly respond to user's operations;\\
\hline
QR-4& Reliability& The Traffic Simulation System should ensure the low frequency of system crashes;\\
\hline
QR-5& Usability& The Traffic Simulation System should have a clear GUI interface that use can use it immediately and easily.\\
\hline
\end{tabular}
\end{table}

\section{Design}
 	The design of this Traffic simulator is divided in 3 parts. Those three parts are:
 	\begin{itemize}
 		\item GUI
 		\item Common
 		\item Simulation
 	\end{itemize}
 	\includegraphics[width=12.5cm]{designIMG.eps}

 	\subsection{about}
 	The Simulation part is the core of the traffic simulator, where the actual computing and decisions of vehicles happen. Common is shared by both Simulation and GUI, it contains classes that are used by both other parts of the Traffic simulator. GUI is where the graphics are drawn and shown to the user, it is the part of the Traffic simulator the user interacts with.
 	\newline
 	We decided to go with this design, because we concluded that it would be the easiest if the Simulation part where the computing happens is completely separated from the GUI part. This way it was simpler for us to work on the project and to divide the work between group members.
 	\subsection{"WorldState"}
 	The only object that the both GUI and Simulation see is the “WorldState” object. The” WorldState” object represent the current state of the Traffic simulator. The Simulation builds the “WorldState” object from the values it computes and then the GUI uses the information and draws the graphics.
 	\subsection{Vehicles}
 	All Vehicles inside Simulation are represented as an interface “IVehicle”, because they share many identical methods that need to be implemented in different ways depending on the vehicle type. But because the GUI doesn’t need all these information we decided to pass a different object to the GUI, an object from common “VehicleDTO”. This object is a much simpler version of the vehicle that contains only the necessary information to draw the vehicle on the correct location.

\section{Implementation}
\subsection{Interaction between the user and the system}
\subsubsection{Description} The majority of interactions between the user and the system come from the Control Panel. The user can control the system through the components in the Control Panel, and the relevant corresponding will be showed in the specific area. The Control Panel can be separated into three parts, they are Simulation Controller, Vehicles Controller and the Traffic Lights Controller. Though Simulation Controller part, the user can control the starting or pausing of the simulation, the clear of the whole simulation, the time step of the simulation, the speed of the timer, the states per second of the simulation, and the display of the debug mode. As to the Vehicles Controller, the user can set the percentage of the different kinds of vehicles, and the behaviors of the drivers. In addition, the interval of switching the traffic lights can be set by the user through the Traffic Lights Controller.
The other interactions happen on the Map Panel. First of all, the user can drag and move the map to see more details of the simulation. Because the size of the map is bigger than the size of the Map Panel, we use this solution to help the user to see the complete map information. Then the user can set or remove the traffic lights just by clicking on the specific junction showed on the map.

\subsubsection{Design and implementation}
\includegraphics[width=12.5cm]{interactionClassGraph.eps}
\paragraph{Class PanelMouseAction} implements MouseInputListener, which is added on the Map Panel. It belongs to ``gui" package. The main task for this class is processing the requests from the Mouse operation in the Map Panel. The first operation is dragging the map. It is easy to implement the function of dragging the panel, however, it will get more complex if we take the range into consider. The map in our system is a rectangle that has limited length and height. So the range of dragging should be the minimum length and width to maximum length and width. The second one is set or remove the traffic lights. In order to ensure the operability, the selectable range should be enlarged to the whole junction. After clicking the junction, the relevant parameters will be sent back to the ``common" package.
\paragraph{Class ControlPanel} extends JPanel, which is added on the Main Frame. It belongs to ``gui" package. It is responsible for most of the interaction works. It uses the static parameter simulationListener in MainFrame to transfer inputs from the user to the server end mostly. While for the setting of debug mode, it transfers the Boolean parameter to the MapPanel directly. In addition, it should do the necessary checking of inputs before passing the values to the server side. For the invalid inputs, it will generate a JDialog object to prompt the user to make the appropriate changes. As to the control of starting or pausing, clearing of the simulation. It will use stateProviderController to control the main thread of the system.
\paragraph{Class ControlPanelDocumentListnener} implements DocumentListener, which is added to the text fields in Control Panel. It belongs to ``gui" package. It is used to check the validity of inputs. If the input is invalid, a JDialog that has related information will be generated.
\paragraph{Class StateProviderController} extends Thread, which is the main thread of the simulation. It belongs to ``thewaypointers.trafficsimulator" package, ControlPanel in ``gui" package holds the reference to it. The thread is generated by the Bootstrapper class, and it keeps sleep state until the user starts the simulation. The Boolean parameter isSleep controlled the starting and pausing of the simulation. When the user chooses to clear the simulation, a new StateProvider will be passed to the simulation.
\paragraph{Class Bootstrapper} is generated by the main starter of the system. It belongs to ``thewaypointers.trafficsimulator" package, and the StateProviderController holds the reference to it. It is used to create the main thread StateProviderController and start it. It also generates the Main Frame and set relevant parameters of the simulation.


\subsubsection{Detailed description of the main function}

\paragraph{ChangeListener trafficLightTimeChange} This function is used to pass the value of the interval of switching traffic lights to the package ``common". The input value that is set by the user will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame.
\paragraph{ChangeListener debugChange} This function is used to pass a Boolean value to MapPanel to control whether display debug mode.
\paragraph{ChangeListener statesPerSecondsChange} This function is used to pass the value of the states per seconds of the simulation to the package ``common". The input value that is set by the user will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame.
\paragraph{ChangeListener simulationSpeedChange} This function is used to pass the value of the speed of timer to the package ``common". The input value that is set by the user will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame.
\paragraph{ChangeListener timeStepChange}This function is used to pass the value of the time step of simulation to the package ``common". The input value that is set by the user will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame.
\paragraph{startPausePerformed(ActionEvent evt)} This function is used to control the main thread of the simulation. When the user presses the start button, the simulation will get start and the button will change to pause. When the user presses the pause button, the simulation will pause and the button change to start.
\paragraph{clearPerformed(ActionEvent evt)} This function is used to end the main thread of the simulation. When the user presses the clear button, the simulation will stop immediately.
\paragraph{submitPerformed(ActionEvent evt)} This function is used to pass the percentages of different kinds of vehicles to the package ``common''. The input value that is set by the user will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame. At the same time, the validity of the input will be checked in this method.

\paragraph{mouseClicked(ActionEvent evt)} This function allows the user to set traffic lights at junctions. When the user clicks on a junction showed on the map, it will set or remove the traffic lights on this junction. The chosen traffic light will be passed through the function SimulationParameterChanged() of simulationInputListener in MainFrame.
\paragraph{mouseDragged(ActionEvent evt)} This function allows the user to drag map inside of the MapPanel and see more details of the simulation. When the user drags the map, the system will check whether the map is in the visible field. If the new location out of the range, the map will be set at the border of the MapPanel.

\paragraph{pauseSimulation()} This function is used to control the main thread of the simulation. It will be invoked when the user presses the ``start/pause'' button. If the operation is  ``start" then the thread will run as normal, while if the operation is ``pause" then the thread will sleep until the user starts the simulation again.
\paragraph{clearSimulation()} This function is used to end the main thread of the simulation. It will be invoked when the user presses the clear button. The thread will stop immediately and generate a new thread of the simulation.
\paragraph{run()}This reconstructed function is used to execute the main thread of the simulation. It will be invoked when the system starts up.

\paragraph{insertUpdate(DocumentEvent e)} This reconstructed function is used to check the validity of the inputs. It will be invoked when the text field has new inputs.  If the input is invalid, a JDialog will pop up to display related information.

\paragraph{bootstrap(String[] args)} This function is used to generate a new thread StateProviderController and start the thread. It also generates the new MainFrame with relevant parameters of simulation controlling. This function is invoked by the main starter of the system.

\subsection{GUI part}

Basically, GUI is to display performance of the whole system, showing the results of how the system runs. In GUI, we draw traffic road on class MapPanel. The MapPanel mainly consist of five parts: to paint road, vehicle, traffic lights, labels and to get statistical data.

\subsubsection{compute$\_$xy( )}
When drawing road, we get the junctions and roads from background. One thing we have to deal with is to compute the coordinate of each junction and road, then draw them on the MapPanel. We assume that the first junction we get from our background is on the top left of the map. So we make the coordinate as $(x,y)=(road_length, road_length)$. Afterwards, based on the location of the first junction, we compute the rest roads and junctions until finishing the whole map. On the contrary, if the first junction we get is not located on the top left, then we move the junction to its correct location. As long as we complete the road map, achieving coordinate of each junction, we can easily compute the relative coordinates of vehicle and traffic lights. Finally, we draw the whole traffic map.

\subsubsection{drawVehicleInJunction( )}
Considering vehicles turning on junctions, we first divide turning situation into the following eight parts, where $\alpha$ represents its turning angle. Then using Java function, AffineTransform(), to rotate the vehicle towards its right way.
\begin{center}
	\includegraphics[width=14cm]{GUI_p1.eps}
\end{center}

\subsubsection{RecordStatistics( )}
Our system will collect the travel distance of every car and then compute their average speed for further analysis, showing on StatisticsPanel. We create a list for the whole system and list information for cars, running time and running distance. The pseudo-code shows as below:
\begin{center}
	\includegraphics[width=6cm] {GUI_p2.eps}
\end{center}

\subsection{about simulation}
The Simulation is the back end of our Traffic Simulator. This runs on a thread and calculates the state of the Traffic Simulator for every n time. It builds the initial state of the simulation using the „WorldState“ object passed on the creation of this class.
\newline
The „WorldState“ object represents the current state of the simulation. The first world state object with it's roads and junctions gets created on the start of the application. The „TrafficSimulatorStarter“ is the main class in which up on start it creates and passes the XML path to the „MapWorldStateFactory“.
This class then finds the XML, parses trough it creating the „WorldState“ object and returns it to the „TrafficSimulatorStarter“.
\newline
The XML files are used to easier create road networks. But for the "Simulation" to work the XML files must follow certain rules.
\begin{itemize}
	\item The Exit nodes names must start with an 'E'
	\item Directions of the roads must be correct
	\item Junctions must be correctly connected to each other
	\item Traffic light junctions must be added as an XML item, other junctions are normal junctions
\end{itemize}
The directions represent on what side of the junction the road starts, so the direction can be: up, left, right and down.
This a simple example of an XML with 4 roads and 1 traffic light junction:
\begin{lstlisting}
<?xml version="1.0"?>
<simulation>
	<roads>
		<road>
			<origin>A</origin>
			<destination>E1</destination>
			<length>300</length>
			<direction>Left</direction>
		</road>
		<road>
			<origin>A</origin>
			<destination>E2</destination>
			<length>300</length>
			<direction>Up</direction>
		</road>
		<road>
			<origin>A</origin>
			<destination>E3</destination>
			<length>300</length>
			<direction>Right</direction>
		</road>
		<road>
			<origin>A</origin>
			<destination>E4</destination>
			<length>300</length>
			<direction>Down</direction>
		</road>
	</roads>
	<junctions>
		<junction>
			<name>A</name>
			<type>JunctionTrafficLights</type>
		</junction>
	</junctions>
</simulation>
\end{lstlisting}
To create the same road network with a normal junction instead of the traffic light junction, it is only needed to remove the junction from the "junctions" part of the xml and leave it like:
\begin{lstlisting}
<junctions>
</junctions>
\end{lstlisting}
\subsection{starting the simulation}
Once the initial „WorldState“ object is created,  „TrafficSimulatorStarter“  creates a new „Simulation“ class and passes „WorldState“  to it. „Simulation“ then builds the road network for itself from that object. It contains a weighted graph which represents the road network. Each node equals a junction and each edge equals one side of the road. The vehicles are stored in a hash map where the edge of the graph is the key, and objects are array lists of vehicles. So that for each road we can store more than one vehicle.
\newline
When we start the simulation it starts a while loop inside which every n seconds the „Simulation“ class calculates a new world state for the time passed. We can manipulate the time and the time step using the GUI. It is also possible to pause or restart the simulation trough the GUI.

\begin{lstlisting}
while (true) {
if (!isSleep) {
worldState = simulation.getNextState(simulationTimeStep);
output.NewStateReceived(worldState);
}
try {
Thread.sleep(timeStep);
} catch (InterruptedException e) {
e.printStackTrace();
}
}
\end{lstlisting}

\subsection{"getNextState"}
Every time „Simulation“ calls „getNextState“ it has to go trough three steps: attemption to spawn vehicles, attemption to change the traffic lights color and calculating the new positions of vehicles.\newline
\subsubsection{Junctions}
There are 3 types of Junctions: traffic light junction, normal junction and the exit node. On every new state „Simulation“ tries to change the traffic light color, this happens only if the required time was met. We implement this by making a traffic light step counter, so the color changes on every n state. Normal junctions differ from the traffic light junctions in means that the vehicle has to give the advantage to the vehicle on it's right. The exit node is the point where vehicles enter and leave the road network.
\newline
\subsubsection{New vehicles}
Once the „Simulation“ tries to create  a new vehicle it has a choice of 4 types of vehicles. Those are: reckless car, cautious car, normal car and emergency service. The difference between cars is that the reckless car drives faster than normal and cautious slower. The emergency service is different in a way that it can pass trough the red traffic light and the cars have stop so it can go trough.
The Simulation decides which of these to create by using the „VehicleSpawnRatio“. It gives the ratio of chance of each of the types to spawn, we can change this ratios in the GUI.
\newline
The entering and leaving exit nodes are decided randomly for every vehicle.
\newline
\subsubsection{Moving vehicles}
After the vehicle spawning and changing of traffic lights „Simulation“ calculates the new position of each of the vehicles on the road network. It does this by iterating trough the vehicles and calling the „calculateNextPosition“ method on them. Each of the vehicle has to calculate their own speed, check if there is a vehicle in front of them blocking their path and then check if they are reaching a node(junction). Once the vehicle reaches the junction it has  a different set of rules depending on the type of the junction. For example for traffic light junctions they need to check if the traffic light is green to enter the junction. Once they know they can enter it, they call the „canGoTroughJunction“ method to avoid collisions with other vehicles in junctions. Each vehicle has to check: if the junction is blocked, if the vehicles inside junctions are going to collide with them, if they are turning left so they can signal the other vehicles that they should pay attention not to hit them and they need to check if the vehicle from the opposite side of the road is turning left.
\newline
We have implemented the blocked junction check because dead locks sometimes happen on the normal junctions which are simpler, because if there is a large amount of vehicles and vehicles are trying to enter the junction from each side of the road they don't know who goes first. In this case the car with the advantage is the one that reached the junction first.
\newline
Once each of the vehicles has calculated it's new position the „Simulation“ updates the world state with the new information. It builds a new „VehicleDTO“ class from the common part for each of the vehicles inside Traffic Simulator, it passes them information about the vehicles like road, location vehicle type, speed.


\section{Teamwork}

\subsection{Tools and libraries used}

\subsubsection*{Tools and applications}

\begin{itemize}
	\item Git\footnote{\url{https://git-scm.com/}} - version control
	\item GitHub\footnote{\url{https://github.com/}} - Git repository management, task assignment, teamwork
	\item \LaTeX\footnote{\url{https://www.latex-project.org/}} - typesetting system, for creating documentation
	\item Gliffy\footnote{\url{https://www.gliffy.com/}} - a Chrome app for creating diagrams
	\item Apache Maven\footnote{\url{https://maven.apache.org/}} - a build tool for building the project easily and for dependency management
	\item Travis CI\footnote{\url{https://travis-ci.org/}} - a continuous integration tool that integrates into GitHub and builds every commit pushed to the repository (in our case - using Maven), also checking if the tests pass
	\item IntelliJ IDEA\footnote{\url{https://www.jetbrains.com/idea/}} - a cross-platform IDE for development in Java (and more). To minimize potential hassles with different development environments, we all agreed on using the same IDE.
\end{itemize}


A significant fact to note that is our team used all the major operating systems (Windows, OS X, Linux), so we focused on choosing cross-platform tools. The only troubles that arised from that were minor layout differences in the Swing GUI of our system.

\subsubsection*{Libraries}

\begin{itemize}
	\item JDK 1.8\footnote{\url{http://www.oracle.com/technetwork/java/javase/downloads/index.html}} - We had several reasons for choosing Java: \begin{itemize}
		\item Familiarity of team members with it
		\item Available on all platforms
		\item Good capabilities of cross-platform GUI
		\item Strong typing allowing for easier maintaining of code integrity
	\end{itemize}
	We chose version 8 because it introduces many much-needed improvements for the language like lambda functions or the Stream API.
	\item JUnit 4.12\footnote{\url{http://junit.org/junit4/}} - The ``de facto'' unit testing library for Java. Good integration with IntelliJ IDEA and Maven.
	\item FEST-Assert 2.0M5\footnote{\url{https://github.com/alexruiz/fest-assert-2.x}} - A library to make assertions in unit tests more readable and easier to compose.
	\item JGraphT 0.7.3 \footnote{\url{http://jgrapht.org/}} - A graph library to take advantage of graph representation of the road network, mainly implementing pathfinding for vehicles.
	\item XStream 1.2.2 \footnote{\url{http://x-stream.github.io/}} - An XML serialization library to bring reading and writing XML road maps to life.
\end{itemize}

\subsection{Process}
We used an Agile method to manage out project. We divided project time into 8 week-long iterations, which started with a meeting every Thursday. Every team member was present every Thursday, barring some serious circumstances. During every meeting, we established the goals to achieve in the next iteration and every team member was assigned tasks to complete within the timeframe of the iteration. If any tasks were leftover from the previous iteration, they were reassigned. The tasks were recorded as GitHub Issues, which allowed us to set labels, current iteration (as ``milestone'') and assignee.

We maintained three levels of branches in the Git repository:
\begin{itemize}
    \item \emph{master} - this branch was the top-level branch, intended for releasing working snapshots of the system. We ended up not using it, because the system was not very usable until we implemented the control panel and statstics in full, which was late in the project cycle.
    \item \emph{dev} - the development branch. Here, the team members merged their new features. If there were merge conflicts, they were resolved on the feature branches so pull requests could be managed from the website easily. All code had to build and pass its tests on Travis.
    \item Feature branches - active development branches. Normally, there was one branch per task belonging to one team member. They were merged into dev when the task was finished (or when the task achieved a stable, partially completed state).
\end{itemize}

There was also a fourth kind of branch, created ad hoc for urgent matters - mostly bugfix branches. Those operated similarly to feature branches, but were not created at the start of the iteration.

When a team member started working on task, they created a new feature branch with the following name format:
$$\verb|feat-{name_of_issue}-{number_of_issue}|$$ This proved very useful for quickly finding an issue associated with a branch and vice versa.

When the work was done, the author submitted a pull request closing the issue. At this point, another team member reviewed the code, checking the Travis build and tests status and potentially making suggestions about improvements.

When the reviewer and the submitter were both satisfied with the state of the pull request, the reviewer closed the pull request and the task by merging the changes into \emph{dev}. We didn't encounter any problems with unresolvable disagreements, but if they occured, we would resolve them by assigning a mediator, and if that failed, a team-wide vote.

\section{Evaluation}

Although we achieved a usable version of the system, we did not have time to implement all features we wanted to - namely, multi-lane roads and buses. This was simply due to the fact that each other's abilities were unknown to us at the start, and the tasks ended up taking more time than planned.

On per-iteration basis, it was also visible that issues were oftes still open after deadlines. That was to be expected, though - since we did not know about each others' cababilities and experience, it was better to assign a considerable amount of work and close it a couple of days after the deadline than to assign little and make a person not contribute much during an iteration.

On the other hand, we have also implemented features we have not planned in the original requirements document. The most prominent example is the capability of reading roadmaps from XML files, which we created in order to store different road map configurations in a manageable way.

\subsubsection*{What went well}
\begin{itemize}
	\item The architecture - Dividing the system into clearly delimited components with defined interfaces was certainly a good idea that reduced complexity in the project and allowed for the simulation and the display part to be developed almost independently. Because we defined the GUI to refresh when accepting a new simulation state, and the simulation to be a state machine which can be asked to produce a new state occuring after N miliseconds, those two components could be easily connected and controlled together.
	\item GitHub Issues - Ideal task assignment system for our use case. We never needed anything more complicated than Issues, and thanks to it being a part of GitHub we managed a very close integration of our tasks with pull requests and the code. It even allowed us to close associated issues while merging pull requests automatically.
	\item Continuous Integration - Setting up Travis was easy, it integrated into GitHub automatically, and it allowed us to catch many broken tests and compilation errors which we would miss otherwise.
	\item Graph representation of the road network - Representing the road network as a graph instead of a 2-dimensional matrix allowed us to focus on what happens on the roads and not where the roads and vehicles are located in two-dimensional space. This also allowed us to pass only the essential world information to the GUI, which could freely display it in the most convenient way. The only disadvantage was that we had to represent junctions in two-dimensional form anyway for the purpose of implementing turning and collision detection on the junction, but since each junction uses its own local coordinates, it is still a clearer representation than full 2D.
\end{itemize}

\subsubsection*{What went less well}
\begin{itemize}
	\item Testing - We have extensively unit-tested several complex areas of code and created several test startup configurations for the system, but in general testing should have been encouraged or enforced more, especially in the simulation component. Both code and the produced effects quickly grew in complexity, which led to manual debugging taking hours. Total debugging time was probably greater than the amount of time writing tests would have taken, and it would also increase flexibility of the code.
\end{itemize}

\subsubsection*{Further improvements for the future}

An obvious way to continue the project in the future is to make the simulation more complex, adding multi-lane roads, different road kinds like main roads and small (rural) roads, roundabouts, buses. It would make the system more realisting and the configurations more interesting to manipulate.

GUI could be made more beautiful: images instead of vector graphics could be added.

Because we have implemented an XML format for road networks, loading arbitrary maps from outside is easy. A map editor can be created to graphically create new maps which could be used in the system.

\section{Peer assessment}

Peer assessment results are shown in table \ref{table:assessment}.

\begin{table}[!htb]
\centering
\caption{Peer assessment}
\label{table:assessment}
\begin{tabular}{|l|l|}
\hline
Haipei Liu      & 20.3 \\ \hline
Karlo Santini   & 19.9 \\ \hline
Michal Szewczak & 24.8 \\ \hline
Mengzhu Wang    & 20.6 \\ \hline
Minghao Zhu     & 14.4 \\ \hline
\end{tabular}
\end{table}

\newpage
\appendix

\etocdepthtag.toc{mtappendix}
\etocsettagdepth{mtchapter}{none}
\etocsettagdepth{mtappendix}{subsection}
\tableofcontents‎‎

\section{Git log}

\lstinputlisting[style=gitlog]{gitlog.txt}

\section{Main source code}

\input{main_code.tex}

\section{Test source code}

\input{test_code.tex}

\end{document}
